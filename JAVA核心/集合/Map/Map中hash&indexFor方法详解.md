> 理解下文知识点，需要掌握一下Java 位运算相关知识点：https://blog.csdn.net/xiaochunyong/article/details/7748713
>
> 参考来自：https://www.zhihu.com/question/20733617

## hash() : 

以下源码来自 jdk 1.8 中hash()， 这段代码称为**“扰动函数”**，只做了一次**16位右位移异或混合**


``` 
static final int hash(Object key){
    int h;
    return (key == null ) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

key.hashCode()函数返回的是key键值类型自带的哈希函数，返回int型散列值。

理论上散列值是一个int型，如果直接拿散列值作为下标直接访问HashMap主数组的话，考虑到2进制32位带符号的int表值范围从-2147483648 到 2147483648。前后加起来大概40亿的映射空间。只要哈希函数映射的比较均匀一般应用很难出现碰撞。

但问题是40亿长度的数组，内存是放不下的。你想HashMap扩容之前的数组初始大小才16。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来访问数组下表。源码中模运算是在这个**indexFor()**函数里完成的,**代码很简单就是把散列值和数组长度做一个“与”操作。**

```
bucketIndex = indexFor(hash, table.length);

static int indexFor(int h, int length){
    return h & (length -1);
}
```

顺便说一下，这也正好解释了为什么HashMap的数组长度要取2的整次幂。因为这样（数组长度-1）正好相当于一个**“低位掩码”。“与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问**。以初始长度16为例，16-1=15。2进制表示就是00000000 00000000 00001111。和散列值做“与”操作如下，结果就是截取了最低的四位值。

```
    10100101 11000100 00100101
  & 00000000 00000000 00001111
    ----------------------------------
    00000000 00000000 00000101    //高位全部归零，只保留末四位
```
但这时候问题就来了，这样就算我的散列值分布再松散，要是只取最后几位的话碰撞也会很严重。更要命的是如果散列本身做得不好，分布上成等差数列的漏洞，恰好使最后几个低位呈现规律性重复，就无比蛋疼。

这时候“扰动函数”的价值就体现出来了，说到这里大家应该猜出来了。看下面这个图，
<div align="center">
  <!-- <img src="../../pics/4acf898694b8fb53498542dc0c5f765a_hd.png" width=""/> -->
  <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf9n4ol0akj30ga09cmxw.jpg" width=""/>
</div><br>

右移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了混合原始hash码的高位和低位，以此来加大低位的随机性。而且混合后的地位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。

